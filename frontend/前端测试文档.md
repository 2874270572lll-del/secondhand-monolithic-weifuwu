# 二手交易平台前端 - 测试文档

## 系统环境

- **操作系统**: Ubuntu 24.04
- **浏览器**: Firefox / Chrome / Chromium
- **后端服务**: 已启动的微服务系统（Docker Compose）

---

## 快速开始

### 1. 确保后端服务已启动

```bash
cd /mnt/share/secondhand-microservices
docker-compose ps

# 确认以下服务都是 Up (healthy) 状态：
# - gateway-service (8080)
# - user-service (8081)
# - product-service-1/2/3 (8082)
# - order-service (8083)
# - comment-service (8084)
# - mysql (3306)
# - nacos (8848)
# - rabbitmq (5672, 15672)
```

### 2. 启动前端

前端使用纯HTML + JavaScript，无需构建，直接用浏览器打开即可。

**方法1：使用Python的HTTP服务器（推荐）**

```bash
# 进入前端目录
cd /mnt/share/secondhand-microservices/frontend

# 启动HTTP服务器
python3 -m http.server 8000

# 看到以下输出表示成功：
# Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
```

然后在浏览器中访问: http://localhost:8000

**方法2：直接用浏览器打开**

```bash
# 使用Firefox打开
firefox /mnt/share/secondhand-microservices/frontend/index.html

# 或使用Chromium打开
chromium-browser /mnt/share/secondhand-microservices/frontend/index.html
```

**注意**: 直接打开HTML文件可能会遇到CORS跨域问题，建议使用方法1。

---

## 解决CORS跨域问题

如果浏览器控制台出现跨域错误，需要在网关服务配置CORS。

### 检查网关配置

网关的 `application.yml` 已经配置了CORS：

```yaml
globalcors:
  cors-configurations:
    '[/**]':
      allowed-origin-patterns: "*"
      allowed-methods: "*"
      allowed-headers: "*"
      allow-credentials: true
```

如果仍有问题，可以临时使用浏览器禁用安全模式：

```bash
# Chrome/Chromium (仅用于测试，不要在正式环境使用)
chromium-browser --disable-web-security --user-data-dir=/tmp/chrome_dev_session http://localhost:8000
```

---

## 完整功能测试流程

### 测试1：用户注册

**步骤**:

1. 打开前端页面 http://localhost:8000
2. 默认显示登录页面，点击"还没有账号？立即注册"
3. 填写注册信息：
   - 用户名: `testuser001`
   - 邮箱: `testuser001@example.com`
   - 密码: `Test123456`（至少8位，包含字母和数字）
4. 点击"注册"按钮

**预期结果**:
- ✅ 页面顶部显示绿色提示"注册成功！请登录"
- ✅ 自动跳转到登录页面
- ✅ 用户名已自动填充

**后端API调用**:
```
POST http://localhost:8080/api/auth/register
{
  "username": "testuser001",
  "email": "testuser001@example.com",
  "password": "Test123456"
}
```

**验证**:

打开浏览器开发者工具（F12）→ Network标签页，查看请求：
- 请求URL: `http://localhost:8080/api/auth/register`
- 请求方法: POST
- 响应状态: 200
- 响应数据: `{"code":200,"message":"success","data":{...}}`

---

### 测试2：用户登录

**步骤**:

1. 在登录页面填写：
   - 用户名: `testuser001`
   - 密码: `Test123456`
2. 点击"登录"按钮

**预期结果**:
- ✅ 页面顶部显示绿色提示"登录成功！"
- ✅ 导航栏右侧显示用户名
- ✅ 导航栏显示"商品列表"、"发布商品"、"我的订单"、"退出"菜单
- ✅ 自动跳转到商品列表页面

**后端API调用**:
```
POST http://localhost:8080/api/auth/login
{
  "username": "testuser001",
  "password": "Test123456"
}
```

**验证**:

查看浏览器开发者工具 → Application → Local Storage:
- `token`: JWT令牌（长字符串）
- `username`: testuser001
- `userId`: 用户ID数字

---

### 测试3：查看商品列表

**步骤**:

1. 登录后自动显示商品列表
2. 如果之前没有商品，显示"暂无商品"
3. 点击右上角"刷新"按钮可以刷新列表

**预期结果**:
- ✅ 页面显示所有商品卡片
- ✅ 每个商品卡片显示：名称、描述、价格、分类、库存
- ✅ 鼠标悬停时卡片有阴影效果

**后端API调用**:
```
GET http://localhost:8080/api/product
```

**验证**:

打开开发者工具 → Network，查看请求：
- 请求URL: `http://localhost:8080/api/product`
- 请求方法: GET
- 响应状态: 200
- 响应数据: `{"code":200,"message":"success","data":[...]}`

---

### 测试4：发布商品

**步骤**:

1. 点击导航栏"发布商品"
2. 填写商品信息：
   - 商品名称: `二手MacBook Pro 2021`
   - 商品描述: `14寸M1 Pro芯片，16GB内存，512GB存储，成色9成新`
   - 价格: `9888`
   - 库存: `1`
   - 分类: 选择"数码产品"
3. 点击"发布商品"按钮

**预期结果**:
- ✅ 页面顶部显示"商品发布成功！"
- ✅ 自动跳转到商品列表页面
- ✅ 新发布的商品出现在列表中

**后端API调用**:
```
POST http://localhost:8080/api/product
Authorization: Bearer <token>
{
  "name": "二手MacBook Pro 2021",
  "description": "14寸M1 Pro芯片，16GB内存，512GB存储，成色9成新",
  "price": 9888,
  "stock": 1,
  "category": "数码产品",
  "sellerId": <userId>
}
```

**验证**:

开发者工具 → Network:
- 请求头包含 `Authorization: Bearer ...`
- 响应状态: 200
- 响应数据包含新创建的商品ID

---

### 测试5：查看商品详情

**步骤**:

1. 在商品列表中，点击任意商品卡片
2. 查看商品详情页面

**预期结果**:
- ✅ 显示商品完整信息
- ✅ 显示"立即购买"按钮
- ✅ 点击"返回列表"可以返回商品列表

**后端API调用**:
```
GET http://localhost:8080/api/product/{id}
```

---

### 测试6：创建订单（购买商品）

**步骤**:

1. 在商品详情页面，点击"立即购买"按钮
2. 弹出确认对话框，点击"确定"

**预期结果**:
- ✅ 页面显示"订单创建成功！"
- ✅ 自动跳转到"我的订单"页面
- ✅ 新订单出现在列表顶部，状态为"待支付"

**后端API调用**:
```
POST http://localhost:8080/api/order
Authorization: Bearer <token>
{
  "userId": <userId>,
  "productId": <productId>,
  "quantity": 1,
  "totalPrice": <price>,
  "shippingAddress": "默认地址",
  "contactPhone": "13800138000"
}
```

**验证**:

1. **查看订单服务日志**（重要！这里可以看到RabbitMQ消息）:
   ```bash
   docker-compose logs order-service | grep -E "📤|📨|✅"
   ```

   预期日志：
   ```
   📤 准备发送订单创建消息: ORD...
   ✅ 订单创建消息发送成功: orderId=X, orderNo=ORD...
   📨 收到订单通知消息: orderNo=ORD...
   📧 [模拟] 向买家发送通知: buyerId=X, orderNo=ORD...
   📧 [模拟] 向卖家发送通知: sellerId=Y, orderNo=ORD...
   ✅ 订单通知处理成功: orderNo=ORD...
   ```

2. **查看RabbitMQ管理界面**:
   - 访问 http://localhost:15672
   - 登录: admin / admin123
   - 进入 Queues 标签页
   - 查看 `order.notification.queue`
   - Total消息数应该增加

---

### 测试7：查看我的订单

**步骤**:

1. 点击导航栏"我的订单"
2. 查看订单列表

**预期结果**:
- ✅ 显示所有订单
- ✅ 每个订单显示：订单号、商品ID、下单时间、配送地址、金额、状态
- ✅ 待支付订单显示"支付"按钮

**后端API调用**:
```
GET http://localhost:8080/api/order/buyer/{userId}
Authorization: Bearer <token>
```

---

### 测试8：支付订单

**步骤**:

1. 在"我的订单"页面，找到状态为"待支付"的订单
2. 点击"支付"按钮
3. 弹出确认对话框，点击"确定"

**预期结果**:
- ✅ 页面显示"支付成功！"
- ✅ 订单状态变为"已支付"
- ✅ "支付"按钮消失

**后端API调用**:
```
PUT http://localhost:8080/api/order/{orderId}/pay
Authorization: Bearer <token>
```

**验证**:

查看商品库存是否减少：
```bash
# 方法1: 刷新商品列表，查看库存
# 方法2: 查看数据库
docker exec -it secondhand-mysql mysql -uroot -plilili2004 -e \
  "USE product_db; SELECT id, name, stock FROM products;"
```

---

### 测试9：退出登录

**步骤**:

1. 点击导航栏右上角"退出"
2. 查看页面变化

**预期结果**:
- ✅ 页面显示"已退出登录"
- ✅ 导航栏恢复到未登录状态（显示"登录"、"注册"）
- ✅ 自动跳转到登录页面

**验证**:

开发者工具 → Application → Local Storage:
- `token`、`username`、`userId` 都已删除

---

## 完整测试流程（端到端）

### 场景：两个用户的完整交易流程

#### 第1步：卖家注册并发布商品

1. 注册卖家账号: `seller001` / `Test123456`
2. 登录
3. 发布商品：
   - 商品名称: `二手iPhone 14 Pro`
   - 价格: `5999`
   - 库存: `2`
   - 分类: `数码产品`
4. 退出登录

#### 第2步：买家注册并购买商品

1. 注册买家账号: `buyer001` / `Test123456`
2. 登录
3. 查看商品列表，找到 `二手iPhone 14 Pro`
4. 点击查看详情
5. 点击"立即购买"
6. 进入"我的订单"，查看新创建的订单（状态：待支付）
7. 点击"支付"按钮
8. 订单状态变为"已支付"

#### 第3步：验证后端消息队列

1. 查看order-service日志：
   ```bash
   docker-compose logs order-service | tail -30
   ```

2. 查看RabbitMQ管理界面:
   - 访问 http://localhost:15672
   - 查看消息处理统计

#### 第4步：验证数据一致性

```bash
# 查看用户数据
docker exec -it secondhand-mysql mysql -uroot -plilili2004 -e \
  "USE user_db; SELECT id, username, email FROM users;"

# 查看商品数据（库存应减少）
docker exec -it secondhand-mysql mysql -uroot -plilili2004 -e \
  "USE product_db; SELECT id, name, stock FROM products;"

# 查看订单数据
docker exec -it secondhand-mysql mysql -uroot -plilili2004 -e \
  "USE order_db; SELECT id, order_no, buyer_id, seller_id, total_amount, status FROM orders;"
```

---

## 浏览器开发者工具调试

### 打开开发者工具

- **Firefox**: 按 `F12` 或 `Ctrl+Shift+I`
- **Chrome/Chromium**: 按 `F12` 或 `Ctrl+Shift+I`

### 查看网络请求

1. 打开开发者工具
2. 切换到 **Network** 标签页
3. 执行操作（如登录、发布商品）
4. 查看请求详情：
   - Request URL
   - Request Method
   - Request Headers (包括Authorization)
   - Request Payload
   - Response (查看返回的JSON数据)

### 查看控制台日志

1. 切换到 **Console** 标签页
2. 查看JavaScript错误或日志输出
3. 如果有错误，会显示红色消息

### 查看本地存储

1. 切换到 **Application** (Chrome) 或 **Storage** (Firefox) 标签页
2. 展开 **Local Storage** → `http://localhost:8000`
3. 查看存储的数据：
   - token
   - username
   - userId

---

## 常见问题

### Q1: 页面打开后无法加载商品，显示"加载商品失败"

**原因**: 后端服务未启动或网络连接问题

**解决方案**:

```bash
# 1. 检查后端服务状态
docker-compose ps

# 2. 检查gateway-service日志
docker-compose logs gateway-service | tail -20

# 3. 手动测试API
curl http://localhost:8080/api/product
```

### Q2: 登录后显示"未授权,请先登录"

**原因**: JWT Token未正确保存或已过期

**解决方案**:

1. 打开开发者工具 → Application → Local Storage
2. 检查是否有 `token` 字段
3. 如果没有，重新登录
4. 如果有但仍然失败，清空Local Storage后重新登录

### Q3: 发布商品时提示"发布失败"

**原因**: 未登录或token无效

**解决方案**:

1. 检查是否已登录（导航栏是否显示用户名）
2. 如果已登录，退出后重新登录
3. 查看开发者工具 → Console，查看具体错误信息

### Q4: 跨域CORS错误

**症状**:
```
Access to fetch at 'http://localhost:8080/api/...' from origin 'http://localhost:8000'
has been blocked by CORS policy
```

**解决方案**:

网关已配置CORS，如果仍有问题：

1. 使用Python HTTP服务器（推荐）：
   ```bash
   cd frontend
   python3 -m http.server 8000
   ```

2. 临时禁用浏览器安全策略（仅测试用）：
   ```bash
   chromium-browser --disable-web-security --user-data-dir=/tmp/chrome_dev http://localhost:8000
   ```

### Q5: 创建订单后看不到RabbitMQ日志

**原因**: 日志被其他信息淹没

**解决方案**:

```bash
# 使用grep过滤日志
docker-compose logs order-service | grep -E "📤|📨|✅|❌"

# 实时查看日志
docker-compose logs -f order-service | grep -E "📤|📨|✅|❌"
```

---

## API路径参考（基于实际代码）

### 认证相关（无需JWT）
- 用户注册: `POST /api/auth/register`
- 用户登录: `POST /api/auth/login`

### 商品相关
- 查询商品列表: `GET /api/product` （无需JWT）
- 查询商品详情: `GET /api/product/{id}` （无需JWT）
- 创建商品: `POST /api/product` （需要JWT）
- 减少库存: `PUT /api/product/{id}/reduce-stock/{quantity}` （内部调用）

### 订单相关（都需要JWT）
- 创建订单: `POST /api/order`
- 查询买家订单: `GET /api/order/buyer/{buyerId}`
- 查询卖家订单: `GET /api/order/seller/{sellerId}`
- 订单支付: `PUT /api/order/{id}/pay`
- 订单发货: `PUT /api/order/{id}/ship`
- 订单完成: `PUT /api/order/{id}/finish`

### 评论相关
- 创建评论: `POST /api/comment` （需要JWT）
- 查询商品评论: `GET /api/comment/product/{productId}` （无需JWT）

---

## 性能测试

### 测试场景：高并发创建订单

**前置条件**:
1. 已有足够库存的商品（如stock=100）
2. 已登录用户

**测试方法**:

快速点击"立即购买"按钮10次，或者编写脚本：

```javascript
// 在浏览器Console中运行
async function testConcurrentOrders() {
    const promises = [];
    for (let i = 0; i < 10; i++) {
        promises.push(buyProduct(8)); // 假设商品ID为8
    }
    await Promise.all(promises);
    console.log('10个订单创建完成');
}
testConcurrentOrders();
```

**验证**:

1. 查看"我的订单"，确认创建了10个订单
2. 查看RabbitMQ管理界面，确认处理了10条消息
3. 查看order-service日志，确认所有消息都被消费

---

## 前端代码说明

### 文件结构

```
frontend/
├── index.html    # 主页面HTML
└── app.js        # JavaScript业务逻辑
```

### 技术栈

- **HTML5**: 页面结构
- **Bootstrap 5.3**: UI框架
- **Font Awesome 6.4**: 图标
- **Vanilla JavaScript**: 业务逻辑（无需框架）

### 核心功能

- **认证管理**: localStorage存储JWT Token
- **API调用**: 使用 Fetch API
- **路由**: 单页面应用，JavaScript控制页面切换
- **状态管理**: 全局变量 `currentUser`
- **消息提示**: Bootstrap Toast

---

## 扩展功能建议

当前前端已实现基础功能，如需扩展可考虑：

1. **商品图片上传**: 集成文件上传功能
2. **评论系统**: 添加商品评论展示和发布
3. **搜索功能**: 商品名称搜索
4. **分类筛选**: 按分类查看商品
5. **订单详情**: 显示订单关联的商品信息
6. **个人中心**: 修改密码、地址管理
7. **卖家订单**: 查看作为卖家的订单
8. **订单发货**: 卖家发货功能

---

**测试愉快！如有问题，请查看浏览器开发者工具的Console和Network标签页。**
